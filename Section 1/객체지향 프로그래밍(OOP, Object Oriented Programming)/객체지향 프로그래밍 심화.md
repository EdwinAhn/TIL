## 객체지향 프로그래밍의 4기둥
![OOP 4기둥](https://github.com/Luxahn/TIL/blob/main/img/OOP%204%E1%84%80%E1%85%B5%E1%84%83%E1%85%AE%E1%86%BC.png)

이 4가지 핵심원리는 자바에만 국한되는 것이 아니라 객체지향 프로그래밍 설계를 지향하는 모든 언어에 적용되는 핵심 중추.


## 상속 (Inheritance)
말 그대로 부모가 가진 것을 자손에게 물려주듯
<br> 상위 클래스의 멤버(필드,메서드,이너 클래스)를 하위 클래스에게 물려주는 것.
<br>그렇기에 하위 클래스의 멤버 수는 상위 클래스의 멤버 수와 같거나 많다.
<br><br> * (더 확실한 이해를 위해 "객체지향 프로그래밍 기초"에서 예시를 들은 '사람모양의 게임캐릭터 제작 예시'를 생각하자.)

![상속 예시]()
<br><br>
### 상속의 이점
- 상속을 통해 코드의 중복을 줄일 수 있다. (효율 증가)
- 다형적 표현이 가능하다.
    * 다형적 표현: 하나의 객체가 여러 모양으로 표현 될 수 있는 것. (Ex. "프로그래머는 프로그래머이다."는 참이다. 그와 동시에 "프로그래머는 사람이다." 또한 참.)

<br><br>

## 상속(Inheritance)을 사용하는 방법
- ``` extends ``` 키워드를 사용한다.

```java
class Person {
    String name;
    int designation;

    void learn(){
        System.out.println("공부");
    };
    void walk(){
        System.out.println("걷기");
    };
    void eat(){
        System.out.println("먹기");
    };
}

class Programmer extends Person { // Person 클래스로부터 상속. extends 키워드 사용 
    String companyName;

    void coding(){
        System.out.println("코딩하기");
    };
}

class Dancer extends Person { // Person 클래스로부터 상속. extends 키워드 사용
    String groupName;

    void dancing(){
		    System.out.println("춤 추기");
		};
}

class Singer extends Person { // Person 클래스로부터 상속. extends 키워드 사용
    String bandName;

    void singing(){
		    System.out.println("노래하기");
		};
    void playGuitar(){
		    System.out.println("기타 치기");
		};
}

public class HelloJava {
    public static void main(String[] args){

        //Person 객체 생성
        Person p = new Person();
        p.name = "김개발";
        p.designation = junior;
        p.learn();
        p.eat();
        p.walk();
        System.out.println(p.name);

        //Programmer 객체 생성
        Programmer pg = new Programmer();
        pg.name = "이코딩";
        pg.designation = senior;
        pg.learn(); // Persons 클래스에서 상속받아 사용 가능
        pg.coding(); // Programmer의 개별 기능
        System.out.println(pg.name);

    }
}
```
<br><br>

### 포함(composite) 관계
```java
 public class Student{
        int id;
        String name;
        Major major;

        public Student(int id, String name, Major major) {
            this.id = id;
            this.name = name;
            this.major = major;
        }

        void showInfo() {
            System.out.println(id + " " + name);
            System.out.println(major.major+ " " + major.school);
        }

        public static void main(String[] args) {
            Major major1 = new Major("컴공", "서울대");
            Major major2 = new Major("경영학", "하버드대");

            Student s = new Student(1, "김개발", major1);
            Student s2 = new Student(2, "이경영", major2);

            s.showInfo();
            s2.showInfo();
        }
    }

    class Major {
        String major, school;

        public Major(String major, String school) {
            this.major = major;
            this.school = school;
        }
    }

```

원래라면 ```Major``` 클래스에 포함되어 있는 인스턴스 변수 major와 school을 각각 ```Student  ``` 클래스의 변수로 정의해줘야 하지만,<br> ```Major``` 클래스로 해당 변수들을 묶어준 다음 ```Student  ``` 클래스 안에 참조변수를 선언하는 방법으로 코드의 중복을 없애고 포함 관계로 코드를 재사용 하고 있다.

### 상속 관계를 맺어야 하는지, 포함 관계를 맺어야 하는지 구분하는 방법
- 상속 관계
    - '~은(는) ~이다.(IS-A)의 문장 형식을 대입해보자.
<br>

- 포함 관계
    - '~은(는) ~을(를) 가지고 있다.(HAS-A)'의 문장 형식을 대입해보자.

둘 중 자연스러운 문장 형식으로 선택하면 된다.



